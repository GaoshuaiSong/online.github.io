{
  "name": "Online.GitHub.io",
  "tagline": "内联函数",
  "body": "### Welcome to GaoshuaiSong GitHub Pages.\r\n\r\n* 引入内联函数是为了解决函数调用效率的问题\r\n\r\n* 由于函数之间的调用，会从一个内存地址调到另外一个内存地址，当函数调用完毕之后还会返回原来函数执行的地址。函数调用会有一定的时间开销，引入内联函数就是为了解决这一问题。\r\n\r\n#define UIKIT_STATIC_INLINE static inline\r\n\r\nUIKIT_STATIC_INLINE UIEdgeInsets UIEdgeInsetsMake(CGFloat top, CGFloat left, CGFloat bottom, CGFloat right) {\r\n    UIEdgeInsets insets = {top, left, bottom, right};\r\n    return insets;\r\n}\r\n\r\nUIKIT_STATIC_INLINE UIOffset UIOffsetMake(CGFloat horizontal, CGFloat vertical) {\r\n    UIOffset offset = {horizontal, vertical};\r\n    return offset;\r\n}\r\n...\r\n\r\n那么引用内联函数到底有什么区别呢？\r\n\r\n\r\n“为了解决函数调用效率的问题”\r\n\r\n\r\n如何解决呢?\r\n\r\n\r\n如果用static inline声明一个内联函数，\r\n\r\n\r\n#ifndef inline_inline_h\r\n#define inline_inline_h\r\n\r\nstatic inline int add(int a, int b){\r\n    return a+b;\r\n}\r\n#endif\r\n\r\nint main(int argc, const char * argv[]) {\r\n    int c = add(1, 2);\r\n    return 0;\r\n}\r\n\r\n#ifndef notInline_Header_h\r\n#define notInline_Header_h\r\n\r\n int add(int a, int b){\r\n    return a+b;\r\n}\r\n\r\n#endif\r\n\r\n\r\nint main(int argc, const char * argv[]) {\r\n    int c = add(1,2);\r\n    return 0;\r\n}\r\n\r\n\r\n在汇编文件中，声明内联函数的代码量几乎是不声明内联代码量的两倍。在没有声明内联函数的汇编中，main函数有单独汇编的。\r\n\r\n \r\n对比两者的mian.m的汇编代码，可以发现，没有使用`static inline修饰的内联函数的mian函数汇编代码中，会出现 call 指令！这就是区别！调用call指令就是就需要： \r\n\r\n\r\n- (1)将下一条指令的所在地址（即当时程序计数器PC的内容）入栈 \r\n\r\n\r\n- (2)并将子程序的起始地址送入PC（于是CPU的下一条指令就会转去执行子程序）。\r\n\r\n\r\n \r\n影响效率的原因就是在解决在call调用这里了。\r\n\r\n\r\n\r\n\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}